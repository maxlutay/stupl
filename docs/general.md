












* multiple inheritance
* function is object
* type is object
* generics is supconstructors
* class is function with () operator specified
* function is class






* ? type is function which produce types
* type w/o generics is equivalent to empty args function
* type is name reserving
* class is memory layout for type


```
    type A{}  equivalent  type_A() -> A.init() :A_memory_layout 
```

* type with generics is equivqlent to function with args

```
    type A{X,Y} equivalent type_A(X:Type,Y:Type) -> ( use(X), use(Y), A.init())
```















```



type <typename> is
[abstract] (class | function) [ < Parent1 [, Parent2] ... ]




```










